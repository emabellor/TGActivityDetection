/*
 * ClassWrapper.cpp
 *
 *  Created on: Feb 11, 2018
 *      Author: mauricio
 */

#include "ClassWrapper.h"

// Must have local includes for compatibility
#include "ClassOpenPose.h"
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/core/core.hpp>
#include "ImageProcess.h"
#include "VideoCapInfo.h"
#include <iostream>
#include <mutex>

// Struct definitions
typedef struct _JNI_RESULT {
    jclass cls;
    jmethodID constructorID;
    jfieldID personID;
    jfieldID bodyPartID;
    jfieldID xID;
    jfieldID yID;
    jfieldID scoreID;
} JNI_RESULT;


// Globals
ClassOpenPose openPose;
JNI_RESULT jniResEnv;
bool loaded = false;

std::vector<VideoCapInfo*> listVideos;
std::mutex mutexList;

// Custom Functions
void LoadJniResultEnv(JNIEnv * env) {
    if (loaded == true)
        return;

    loaded = true;

    jniResEnv.cls = env->FindClass("activitybesa/ClassResults");

    if(jniResEnv.cls == NULL){
    	std::cerr << "Can't find class name" << std::endl;
    	exit(1);
    } else {
		jniResEnv.constructorID = env->GetMethodID(jniResEnv.cls, "<init>", "()V");

		if(jniResEnv.constructorID == NULL){
			std::cerr << "Can't find constructor" << std::endl;
			exit(1);
		} else {
			jniResEnv.personID = env->GetFieldID(jniResEnv.cls, "person", "I");
			jniResEnv.bodyPartID = env->GetFieldID(jniResEnv.cls, "bodyPart", "I");
			jniResEnv.xID = env->GetFieldID(jniResEnv.cls, "x", "D");
			jniResEnv.yID = env->GetFieldID(jniResEnv.cls, "y", "D");
			jniResEnv.scoreID = env->GetFieldID(jniResEnv.cls, "score", "D");
		}
    }
}


// Defined Functions
JNIEXPORT void JNICALL Java_activitybesa_ClassWrapper_InitOpenPose(JNIEnv * env, jobject obj) {
	openPose.InitOpenPose();
	openPose.jniFlag = true;
	std::cout << "OpenPose Initialized and jni set" << std::endl;
}


JNIEXPORT jobject JNICALL Java_activitybesa_ClassWrapper_ProcessImage(JNIEnv * env, jobject obj, jbyteArray imageBin) {
	// Conversion to unsigned char *
    int len = env->GetArrayLength(imageBin);
    unsigned char* buf = new unsigned char[len];
    env->GetByteArrayRegion (imageBin, 0, len, reinterpret_cast<jbyte*>(buf));

    // Image Processing
    cv::Mat image = ImageProcess::GetFromCharBuffer(buf, len);

    // Process
    auto results = openPose.ExtractKeyPoints(image);
    auto resultPeople = results.GetAllPoints();

    // Iterating
    LoadJniResultEnv(env);
    jobjectArray jPosRecArray = env->NewObjectArray(resultPeople.size(), jniResEnv.cls, NULL);

    for (uint i = 0; i < resultPeople.size(); i++) {
    	auto elem = resultPeople.at(i);

    	// Set fields
    	jobject item = env->NewObject(jniResEnv.cls, jniResEnv.constructorID);
    	env->SetIntField(item, jniResEnv.personID, elem.person);
    	env->SetIntField(item, jniResEnv.bodyPartID, elem.bodyPart);
    	env->SetDoubleField(item, jniResEnv.xID, elem.pos.x);
    	env->SetDoubleField(item, jniResEnv.yID, elem.pos.y);
    	env->SetDoubleField(item, jniResEnv.scoreID, elem.score);

    	// Adding to array
    	env->SetObjectArrayElement(jPosRecArray, i, item);
    }

    std::cout << "Array created!" << std::endl;
    return jPosRecArray;
}

std::string ClassWrapper_LoadVideo(std::string path) {
	std::string returnValue;

	VideoCapInfo * capInfo = new VideoCapInfo(path);
	if (capInfo->IsOpened() == false) {
		std::cerr << "Can't open " << path << std::endl;
		delete(capInfo); // ReleaseMemory
		returnValue = "";
	} else {
		// Add cap info to list - Must have exclusion to avoid change of elements
		mutexList.lock();
		listVideos.push_back(capInfo);
		mutexList.unlock();

		returnValue = capInfo->GetGUID();
	}

	return returnValue;
}

JNIEXPORT jstring JNICALL Java_activitybesa_ClassWrapper_LoadVideo (JNIEnv * env, jobject obj, jstring path) {
	// Loading elements
	const char* nativeString = env->GetStringUTFChars(path, 0);
	std::string pathStr(nativeString);
	std::cout << "String: " << pathStr << std::endl;

	// Return value
	std::string returnValue = ClassWrapper_LoadVideo(pathStr);

	// Return JNI call
	return env->NewStringUTF(returnValue.c_str());
}

FrameInfo ClassWrapper_GetNextImage22(std::string guidStr) {
	std::cout << "Initializing elem 2: " << guidStr << std::endl;

	// Check guid in list - Must have exclusion
	FrameInfo frame;
	frame.isEmpty = true;

	// Init mutual exclusion
	mutexList.lock();
	bool found = false;
	uint index = 0;

	for (uint i = 0; i < listVideos.size(); i++) {
		VideoCapInfo* elem = listVideos.at(i);

		if (guidStr.compare(elem->GetGUID()) == 0) {
			index = i;
			found = true;
			break;
		}
	}

	std::cout << "Found: " << found << std::endl;
	if (found == false) {
		std::cout << "Could not find guid " << guidStr << std::endl;
	} else {
		auto elem = listVideos.at(index);
		frame = elem->GetNextImage();

		if (frame.isEmpty == true) {
			std::cout << "Frame is empty. Removing from list" << std::endl;
			listVideos.erase(listVideos.begin() + index);
			delete(elem);
		}
	}

	// Remove mutual exclusion
	mutexList.unlock();

	// Done!
	return frame;
}

JNIEXPORT jbyteArray JNICALL Java_activitybesa_ClassWrapper_GetNextImage(JNIEnv * env, jobject obj, jstring guid) {
	std::cout << "Initializing" << std::endl;

	const char* nativeString = env->GetStringUTFChars(guid, 0);
	std::string guidStr(nativeString);
	std::cout << "Guid String: " << guidStr << std::endl;

	std::cout << "Guid String2: " << guidStr << std::endl;
	FrameInfo frame = ClassWrapper_GetNextImage(guidStr);
	FrameInfo frame;

	// Return byte array
	if (frame.isEmpty == true) {
	    jbyteArray jarray = env->NewByteArray(0);
	    return jarray;
	} else {
		jbyteArray jarray = env->NewByteArray(frame.len);
	    env->SetByteArrayRegion(jarray, 0, frame.len, reinterpret_cast<signed char*>(frame.image));
	    return jarray;
	}
}

