#include "imageprocess.h"

using namespace cv;
using namespace std;

//Variable Redefinition
const int ImageProcess::EROSION_SIZE = 1;
const int ImageProcess::DILATION_SIZE = 1;

ImageProcess::ImageProcess()  {

}


Mat ImageProcess::Erode(Mat image, int shape) {
    Mat erosion_dst;
    Mat element = getStructuringElement(shape, Size(2*EROSION_SIZE + 1, 2*EROSION_SIZE+1), Point(EROSION_SIZE, EROSION_SIZE));
    erode(image, erosion_dst, element );
    return erosion_dst;
}

Mat ImageProcess::Dilate(Mat image, int shape) {
    Mat dilate_dst;
    cout << "Aplying dilating operation" << endl;
    Mat element = getStructuringElement(shape, Size(2*DILATION_SIZE + 1, 2*DILATION_SIZE+1), Point(DILATION_SIZE, DILATION_SIZE));
    dilate(image, dilate_dst, element);
    return dilate_dst;
}

Mat ImageProcess::Threshold(Mat image, double threshValue, int type) {
    Mat result;
    threshold(image, result, threshValue, 255, type);
    return result;
}

Mat ImageProcess::Grayscale(Mat image) {
    Mat result;
    cvtColor(image, result, CV_BGR2GRAY);
    return result;
}

//Realiza la detección de blobs y los dibuja por medio de un círculo
Mat ImageProcess::DrawBlobs(Mat image) {
    //SimpleBlobDetector
    SimpleBlobDetector detector;

    // Detect blobs.
    std::vector<KeyPoint> keypoints;
    detector.detect(image, keypoints);

    // Draw detected blobs as red circles.
    // DrawMatchesFlags::DRAW_RICH_KEYPOINTS flag ensures the size of the circle corresponds to the size of blob
    Mat im_with_keypoints;
    drawKeypoints(image, keypoints, im_with_keypoints, Scalar(0,0,255), DrawMatchesFlags::DRAW_RICH_KEYPOINTS);

    return im_with_keypoints;
}

Mat ImageProcess::Blur(Mat image) {
    Mat result;
    blur(image, result, Size(3, 3));
    return result;
}

void ImageProcess::ShowAndWait(Mat image) {
    namedWindow("ImageShow");
    imshow("ImageShow", image);
    waitKey(0);
}

Mat ImageProcess::HistEqualization(Mat image) {
    Mat result;
    equalizeHist(image, result);
    return result;
}

Mat ImageProcess::BlurGaussian(Mat image) {
    Mat result;
    GaussianBlur(image, result, Size(3, 3), 0, 0);
    return result;
}


void ImageProcess::ShowSingleImage(Mat image) {
    cvNamedWindow("image");
    imshow("image", image);
    waitKey(0);
    destroyWindow("image");
}

double ImageProcess::GetMean(Mat image) {
    double result;

    if (image.type() != CV_8UC1) {
        cout << "Image is not grayscale" << endl;
        result = -1;
    } else {
        double mean = 0;
        int counter = 0;

        for (int x = 0; x < image.cols; x++) {
            for (int y = 0; y < image.rows; y++) {
                Scalar intensity = image.at<uchar>(y, x);
                auto value = intensity.val[0];

                mean += value;
                counter++;
            }
        }

        mean = mean / counter;
        result = mean;
    }

    return result;
}



