/*
 * ClassWrapper.cpp
 *
 *  Created on: Feb 11, 2018
 *      Author: mauricio
 */

#include "ClassWrapper.h"

// Must have local includes for compatibility
#include "ClassOpenPose.h"
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/core/core.hpp>
#include "ImageProcess.h"
#include "VideoCapInfo.h"
#include <iostream>
#include <mutex>

// Struct definitions
typedef struct _JNI_RESULT {
    jclass cls;
    jmethodID constructorID;
    jfieldID personID;
    jfieldID bodyPartID;
    jfieldID xID;
    jfieldID yID;
    jfieldID scoreID;
} JNI_RESULT;

// Using definitions
using json = nlohmann::json;

// Globals
ClassOpenPose openPose;
std::vector<VideoCapInfo*> listVideos;
std::mutex mutexList;

// Custom Functions
JNI_RESULT LoadJniResultEnv(JNIEnv * env) {
	// Always have to be loaded
	// Class definition changes over time
	JNI_RESULT jniResEnv;

    jniResEnv.cls = env->FindClass("activitybesa/ClassResults");

    if(jniResEnv.cls == NULL){
    	std::cerr << "Can't find class name" << std::endl;
    	exit(1);
    } else {
		jniResEnv.constructorID = env->GetMethodID(jniResEnv.cls, "<init>", "()V");

		if(jniResEnv.constructorID == NULL){
			std::cerr << "Can't find constructor" << std::endl;
			exit(1);
		} else {
			jniResEnv.personID = env->GetFieldID(jniResEnv.cls, "person", "I");
			jniResEnv.bodyPartID = env->GetFieldID(jniResEnv.cls, "bodyPart", "I");
			jniResEnv.xID = env->GetFieldID(jniResEnv.cls, "x", "D");
			jniResEnv.yID = env->GetFieldID(jniResEnv.cls, "y", "D");
			jniResEnv.scoreID = env->GetFieldID(jniResEnv.cls, "score", "D");
		}
    }

    return jniResEnv;
}


// Defined Functions
JNIEXPORT void JNICALL Java_activitybesa_ClassWrapper_InitOpenPose(JNIEnv * env, jobject obj) {
	openPose.InitOpenPose();
	openPose.jniFlag = true;
	std::cout << "OpenPose Initialized and jni set" << std::endl;
}


JNIEXPORT jobject JNICALL Java_activitybesa_ClassWrapper_ProcessImage(JNIEnv * env, jobject obj, jbyteArray imageBin) {
	// Conversion to unsigned char *
    int len = env->GetArrayLength(imageBin);
    unsigned char* buf = new unsigned char[len];
    env->GetByteArrayRegion (imageBin, 0, len, reinterpret_cast<jbyte*>(buf));

    // Image Processing
    cv::Mat image = ImageProcess::GetFromCharBuffer(buf, len);

    // Process
    auto results = openPose.ExtractKeyPoints(image);
    auto resultPeople = results.GetAllPoints();

    // Iterating
    JNI_RESULT jniResEnv = LoadJniResultEnv(env);
    std::cout << "Creating jni object size " <<  resultPeople.size() << std::endl;
    jobjectArray jPosRecArray = env->NewObjectArray(resultPeople.size(), jniResEnv.cls, NULL);
    std::cout << "Object created" << std::endl;

    for (uint i = 0; i < resultPeople.size(); i++) {
    	auto elem = resultPeople.at(i);

    	// Set fields
    	jobject item = env->NewObject(jniResEnv.cls, jniResEnv.constructorID);
    	env->SetIntField(item, jniResEnv.personID, elem.person);
    	env->SetIntField(item, jniResEnv.bodyPartID, elem.bodyPart);
    	env->SetDoubleField(item, jniResEnv.xID, elem.pos.x);
    	env->SetDoubleField(item, jniResEnv.yID, elem.pos.y);
    	env->SetDoubleField(item, jniResEnv.scoreID, elem.score);

    	// Adding to array
    	env->SetObjectArrayElement(jPosRecArray, i, item);
    }

    std::cout << "Array created!" << std::endl;
    return jPosRecArray;
}

std::string ClassWrapper_LoadVideo(std::string path) {
	std::string returnValue;

	VideoCapInfo * capInfo = new VideoCapInfo(path);
	if (capInfo->IsOpened() == false) {
		std::cerr << "Can't open " << path << std::endl;
		delete(capInfo); // ReleaseMemory
		returnValue = "";
	} else {
		// Add cap info to list - Must have exclusion to avoid change of elements
		mutexList.lock();
		listVideos.push_back(capInfo);
		mutexList.unlock();

		returnValue = capInfo->GetGUID();
	}

	return returnValue;
}

JNIEXPORT jstring JNICALL Java_activitybesa_ClassWrapper_LoadVideo (JNIEnv * env, jobject obj, jstring path) {
	// Loading elements
	const char* nativeString = env->GetStringUTFChars(path, 0);
	std::string pathStr(nativeString);
	std::cout << "String: " << pathStr << std::endl;

	// Return value
	std::string returnValue = ClassWrapper_LoadVideo(pathStr);

	// Return JNI call
	return env->NewStringUTF(returnValue.c_str());
}

FrameInfo ClassWrapper_GetNextImage(std::string guidStr) {
	// Check guid in list - Must have exclusion
	FrameInfo frame;
	frame.isEmpty = true;

	// Init mutual exclusion
	mutexList.lock();
	bool found = false;
	uint index = 0;

	for (uint i = 0; i < listVideos.size(); i++) {
		VideoCapInfo* elem = listVideos.at(i);

		if (guidStr.compare(elem->GetGUID()) == 0) {
			index = i;
			found = true;
			break;
		}
	}

	if (found == false) {
		std::cout << "Could not find guid " << guidStr << std::endl;
	} else {
		auto elem = listVideos.at(index);
		frame = elem->GetNextImage();

		if (frame.isEmpty == true) {
			std::cout << "Frame is empty. Removing from list" << std::endl;
			listVideos.erase(listVideos.begin() + index);
			delete(elem);
		}
	}

	// Remove mutual exclusion
	mutexList.unlock();

	// Done!
	return frame;
}

JNIEXPORT jbyteArray JNICALL Java_activitybesa_ClassWrapper_GetNextImage(JNIEnv * env, jobject obj, jstring guid) {
	const char* nativeString = env->GetStringUTFChars(guid, 0);
	std::string guidStr(nativeString);
	FrameInfo frame = ClassWrapper_GetNextImage(guidStr);

	// Return byte array
	if (frame.isEmpty == true) {
	    jbyteArray jarray = env->NewByteArray(0);
	    return jarray;
	} else {
		jbyteArray jarray = env->NewByteArray(frame.len);
	    env->SetByteArrayRegion(jarray, 0, frame.len, reinterpret_cast<signed char*>(frame.image));
	    return jarray;
	}
}

JNIEXPORT jdoubleArray JNICALL Java_activitybesa_ClassWrapper_Convert2DPoint(JNIEnv * env, jobject obj, jstring cameraMatrix,
								jstring distortionMatrix, jstring rVec, jstring tVec, jdoubleArray point) {
	jsize size = env->GetArrayLength(point);
	std::vector<double> input(size);
	env->GetDoubleArrayRegion(point, 0, size, &input[0]);

	const char* cameraMatStr = env->GetStringUTFChars(cameraMatrix, 0);
	cv::Mat camMat = ImageProcess::LoadFromCSV(std::string(cameraMatStr));

	const char* distMatStr = env->GetStringUTFChars(distortionMatrix, 0);
	cv::Mat disMat = ImageProcess::LoadFromCSV(std::string(distMatStr));

	const char* rVectStr = env->GetStringUTFChars(rVec, 0);
	cv::Mat rVecMat = ImageProcess::LoadFromCSV(std::string(rVectStr));

	const char* tVectStr = env->GetStringUTFChars(tVec, 0);
	cv::Mat tVecMat = ImageProcess::LoadFromCSV(std::string(tVectStr));


	std::cout << "CameraMatrix: " << camMat << std::endl;
	std::cout << "distMat: " << disMat << std::endl;
	std::cout << "rVect: " << rVecMat << std::endl;
	std::cout << "tVect: " << tVecMat << std::endl;

	cv::Point2f pointCv(input.at(0), input.at(1));
	std::cout << "PointCV: " << pointCv << std::endl;

	auto result = ClassMain::Project2DTo3D(pointCv, camMat, rVecMat, tVecMat, disMat);

	std::vector<double> output;
	output.push_back(result.x);
	output.push_back(result.y);

	jdoubleArray outputArray = env->NewDoubleArray(output.size());
	env->SetDoubleArrayRegion(outputArray, 0, output.size(), &output[0]);

	// Performs return of double
	return outputArray;
}


JNIEXPORT jstring JNICALL Java_activitybesa_ClassWrapper_CalibrateCamera(JNIEnv * env, jobject obj, jstring jsonJava) {
	std::cout << "Initializing calibrate camera" << std::endl;

	const char* jsonPtr = env->GetStringUTFChars(jsonJava, 0);

	json jsonObj = json::parse(std::string(jsonPtr));

}


