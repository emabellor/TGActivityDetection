/*
 * ClassMain.cpp
 *
 *  Created on: Feb 4, 2018
 *      Author: mauricio
 */

#include "ClassMain.h"

using namespace std;
using namespace cv;



ClassMain::ClassMain() {
	// TODO Auto-generated constructor stub

}

ClassMain::~ClassMain() {
	// TODO Auto-generated destructor stub
}

void ClassMain::InitLogger() {

}


void ClassMain::InitProcess(int argc, char** argv) {
	cout << "OpenCV Version: " << CV_VERSION << endl;

	cout << "Initializing process" << endl;

	int response = 0;
	while (true) {
		cout << "Select case" << endl;
		cout << "1: ShowKeyPoints" << endl;
		cout << "2: SelectKeyPoints" << endl;
		cout << "3: Person re-identification" << endl;
		cout << "4: Extract key poses descriptors" << endl;
		cout << "5: Clustering pose descriptors" << endl;
		cout << "6: Test Draw Pose" << endl;
		cout << "7: Extract descriptors lu" << endl;
		cout << "8: Test video cap info" << endl;
		cout << "9: Test video wrapper" << endl;
		cout << "10: Convert video MJPEG" << endl;

		cin >> response;

		if (response < 1 || response > 10) {
			cout << "You must insert a number between 1 and 8" << endl;
		} else {
			break;
		}
	}

	switch (response) {
		case 1: {
			ProcessKeyPoints(argc, argv);
			break;
		}
		case 2: {
			ShowKeyPoints(argc, argv);
			break;
		}
		case 3: {
			PersonReidentification(argc, argv);
			break;
		}
		case 4: {
			ExtractKeyPosesDescriptor(argc, argv);
			break;
		}
		case 5: {
			Clustering(argc, argv);
			break;
		}
		case 6: {
			TestDrawPose(argc, argv);
			break;
		}
		case 7: {
			ExtractDescriptorsDu(argc, argv);
			break;
		}
		case 8: {
			TestVideoCapInfo(argc, argv);
			break;
		}
		case 9: {
			TestVideoWrapper(argc, argv);
			break;
		}
		case 10: {
			TestConvertVideoMJPEG(argc, argv);
			break;
		}
		default: {
			cout << "Response invalid!" << endl;
		}
	}
}

void ClassMain::ProcessKeyPoints(int argc, char** argv) {
	cout << "ProcessKeyPoints" << endl;

	ClassOpenPose poseDetector;

	cout << "Initializing" << endl;
	poseDetector.InitOpenPose();

	string imagePath = defaultImage;

	if (argc > 2) {
		imagePath = string(argv[1]);
	}

	cout << "ImagePath: " << imagePath << endl;

	Mat image1 = imread(imagePath);

	cout << "Extracting data" << endl;
	poseDetector.ExtractAndShow(image1);

	cout << "ProcessKeyPoints finished" << endl;
}

void ClassMain::ShowKeyPoints(int argc, char** argv) {
	cout << "ShowKeyPoints" << endl;

	ClassOpenPose poseDetector;

	cout << "Initializing" << endl;
	poseDetector.InitOpenPose();

	string imagePath = defaultImage;

	if (argc > 2) {
		imagePath = string(argv[1]);
	}

	cout << "ImagePath: " << imagePath << endl;

	Mat image1 = imread(imagePath);

	cout << "Extracting data" << endl;
	auto results = poseDetector.ExtractKeyPoints(image1);
	auto listElems = results.GetAllPoints();

	cout << "List elements count: " << listElems.size() << endl;
	for (uint i = 0; i < listElems.size(); i++) {
		auto item = listElems[i];
		cout << "Person: " << item.person << " BodyPart: " << item.bodyPart << " x: "  << item.pos.x
				<< " y: " << item.pos.y << " score: " << item.score << endl;

		cv::Point pointInit;
		pointInit.x = item.pos.x - rectSize / 2;
		pointInit.y = item.pos.y - rectSize / 2;

		cv::Point pointEnd;
		pointEnd.x = item.pos.x + rectSize / 2;
		pointEnd.y = item.pos.y + rectSize / 2;

		cv::rectangle(image1, pointInit, pointEnd, cv::Scalar(255, 0, 0));
	}

	cout << "Showing image" << endl;
	cv::namedWindow("winMain", CV_WINDOW_AUTOSIZE);
	cv::imshow("winMain", image1);
	cv::waitKey(0);

	cout << "Process Finished!" << endl;
}

void ClassMain::PersonReidentification(int argc, char** argv) {
	cout << "Person re-identification run" << endl;

	ClassOpenPose poseDetector;
	poseDetector.InitOpenPose();

	cout << "Loading images" << endl;
	cout << "Image1 Path: " << defaultCompareImage1 << endl;
	cout << "Image2 Path: " << defaultCompareImage2 << endl;

	cv::Mat image1 = imread(defaultCompareImage1);
	cv::Mat image2 = imread(defaultCompareImage2);

	cout << "Extract points from image" << endl;

	auto results1 = poseDetector.ExtractKeyPoints(image1);
	auto results2 = poseDetector.ExtractKeyPoints(image2);

	if (results1.GetPeopleAmount() != 1) {
		cout << "People number from image1 is not 1" << endl;
	} else if (results2.GetPeopleAmount() != 1) {
		cout << "People number from image2 is not 1" << endl;
	} else {
		// Right elbow - 3
		// Left elbow - 4
		// Right knee - 9
		// Left knee - 12

		auto pose1RU = results1.GetPose(0, 3);
		auto pose1LU = results1.GetPose(0, 6);

		auto pose2RU = results2.GetPose(0, 3);
		auto pose2LU = results2.GetPose(0, 6);

		double color1U = GetColorPoses(image1, pose1RU, pose1LU);
		double color2U = GetColorPoses(image2, pose2RU, pose2LU);

		cout << endl;
		if (color1U == -1) {
			cout << "Image1 upper ignored" << endl;
		} else if (color2U == -1) {
			cout << "Image2 upper ignored" << endl;
		} else {
			cout << "Color1U " << color1U << endl;
			cout << "Color2U " << color2U << endl;
			cout << endl;
		}

		auto pose1RD = results1.GetPose(0, 9);
		auto pose1LD = results1.GetPose(0, 12);

		auto pose2RD = results2.GetPose(0, 9);
		auto pose2LD = results2.GetPose(0, 12);

		double color1D = GetColorPoses(image1, pose1RD, pose1LD);
		double color2D = GetColorPoses(image2, pose2RD, pose2LD);

		if (color1D == -1) {
			cout << "Image1 lower ignored" << endl;
		} else if (color2D == -1) {
			cout << "Image2 lower ignored" << endl;
		} else {
			cout << "Color1D " << color1D << endl;
			cout << "Color2D " << color2D << endl;
			cout << endl;
		}

		cout << "Program finished successfully" << endl;
	}
}

double ClassMain::GetColorPoses(cv::Mat image, StructPoints pose1, StructPoints pose2) {
	double result = 0;
	int count = 0;

	if (pose1.score >= scoreThresh) {
		cv::Rect rectangle(pose1.pos.x - rectSize / 2, pose1.pos.y - rectSize / 2, rectSize, rectSize);
		auto color = ImageProcess::GetAverageColor(image, rectangle);

		result += color;
		count++;
	}

	if (pose2.score >= 0.5) {
		cv::Rect rectangle(pose2.pos.x - rectSize / 2, pose2.pos.y - rectSize / 2, rectSize, rectSize);
		auto color = ImageProcess::GetAverageColor(image, rectangle);

		result += color;
		count++;
	}

	if (count == 0) {
		result = -1;
	} else {
		result = result / count;
	}

	return result;

}

// Based on Du article
void ClassMain::ExtractDescriptorsDu(int argc, char** argv) {
	cout << "Initializing ExtractDescriptorsDu" << endl;

	vector<DescriptorDu> listDescriptors;
	// Walk
	{
		DescriptorDu desc;
		desc.identifier = 0;
		desc.files = FileHandler::ReadAllFiles("/home/mauricio/Videos/Datasets/Weizzman/walk/");
		listDescriptors.push_back(desc);
	}
	// Run
	{
		DescriptorDu desc;
		desc.identifier = 1;
		desc.files = FileHandler::ReadAllFiles("/home/mauricio/Videos/Datasets/Weizzman/run/");
		listDescriptors.push_back(desc);
	}
	// Jump
	{
		DescriptorDu desc;
		desc.identifier = 2;
		desc.files = FileHandler::ReadAllFiles("/home/mauricio/Videos/Datasets/Weizzman/jump/");
		listDescriptors.push_back(desc);
	}
	// Side
	{
		DescriptorDu desc;
		desc.identifier = 3;
		desc.files = FileHandler::ReadAllFiles("/home/mauricio/Videos/Datasets/Weizzman/side/");
		listDescriptors.push_back(desc);
	}
	// Bend
	{
		DescriptorDu desc;
		desc.identifier = 4;
		desc.files = FileHandler::ReadAllFiles("/home/mauricio/Videos/Datasets/Weizzman/bend/");
		listDescriptors.push_back(desc);
	}


	cout << "Initializing poses" << endl;
	ClassOpenPose poseDetector;
	poseDetector.jniFlag = true;
	poseDetector.InitOpenPose();

	std::string outputFolder = "/home/mauricio/folderdu";


	cout << "Initializing processing" << endl;
	string textToWrite = "";

	for (uint cls = 0; cls < listDescriptors.size(); cls++) {
		auto listVideos = listDescriptors.at(cls).files;
		auto groupId = listDescriptors.at(cls).identifier;

		for (uint index = 0; index < listVideos.size(); index++) {
			auto videoFile = listVideos.at(index);
			cout << "Opening video file" << videoFile << endl;
			auto listImages = ImageProcess::GetImagesFromVideo(videoFile);

			cout << "Total image length: " << listImages.size() << endl;

			// Array struct
			vector<StructDu> listArrays;
			for (uint i = 0; i < listImages.size(); i++) {
				if (i % 10 == 0) {
					cout << "Frame: "  << i << endl;
				}

				auto image = listImages.at(i);
				auto results = poseDetector.ExtractKeyPoints(image);

				cout << "Getting people amount " << results.GetPeopleAmount() << endl;
				if (results.GetPeopleAmount() != 1) {
					cout << "Only one person per image" << endl;
				} else {
					// Step 1 - Same points
					// Must be translated
					int personIndex = 0;
					auto resultPerson = results.GetPointsByPersonTranslate(personIndex);

					// Step 2 - Vector generation: X, Y, Z
					StructDu arrays;

					// Step 3 - Vector serialization
					double min_x = 0;
					double max_x = 0;
					double min_y = 0;
					double max_y = 0;

					for (int i = 0; i < 14; i++) {
						// X
						arrays.arrayX[i] = resultPerson.at(i).pos.x;
						if (resultPerson.at(i).pos.x < min_x) {
							min_x = resultPerson.at(i).pos.x;
						}

						if (resultPerson.at(i).pos.x > max_x) {
							max_x = resultPerson.at(i).pos.x;
						}

						// Y
						arrays.arrayY[i] = resultPerson.at(i).pos.y;
						if (resultPerson.at(i).pos.y < min_y) {
							min_y = resultPerson.at(i).pos.y;
						}

						if (resultPerson.at(i).pos.y > max_y) {
							max_y = resultPerson.at(i).pos.y;
						}

						// Z
						arrays.arrayZ[i] = 0;
					}


					// Step 4 - Normalization
					for (int i = 0; i < 14; i++) {
						arrays.arrayX[i] = 255 * (arrays.arrayX[i] - min_x) / (max_x - min_x);
						arrays.arrayY[i] = 255 * (arrays.arrayY[i] - min_y) / (max_y - min_y);
					}

					listArrays.push_back(arrays);
				}

			}

			// Step 5 - Image creation
			int rows = 14;
			int cols = listArrays.size();

			Mat imageResult(rows, cols, CV_8UC3, Scalar::all(0));
			for (int j = 0; j < cols; j++)  {
				for (int i = 0; i < rows; i++) {
					auto elem = listArrays.at(j);

					Vec3b color;

					color.val[0] = 0; // B
					color.val[1] = (uchar)elem.arrayY[i]; // G
					color.val[2] = (uchar)elem.arrayX[i]; // R

					imageResult.at<Vec3b>(Point(j, i)) = color;
				}
			}

			// Step 6 - Check if output folder exists
			if (FileHandler::DirectoryExists(outputFolder) == false) {
				FileHandler::CreateDirectory(outputFolder);
			}

			// Parsing strategy
			string stem = FileHandler::GetFileNameNoExtension(videoFile);
			string fileName = "video%" + to_string(groupId) + "%" + stem + ".jpg";
			string fullName = FileHandler::JoinPath(outputFolder, fileName);

			cv::Mat imgResize = ImageProcess::Resize(imageResult, Size(64, 64));
			imwrite(fullName, imgResize);
		}
	}

	cout << "Function succeded!" << endl;
}

void ClassMain::ExtractKeyPosesDescriptor(int argc, char** argv) {
	// Based on Weizzman dataset

	vector<string> listVideos;
	listVideos.push_back("/home/mauricio/Videos/Datasets/Weizzman/walk/daria_walk.avi");
	listVideos.push_back("/home/mauricio/Videos/Datasets/Weizzman/jump/daria_jump.avi");
	listVideos.push_back("/home/mauricio/Videos/Datasets/Weizzman/run/daria_run.avi");

	cout << "Extracting poses" << endl;
	ClassOpenPose poseDetector;
	poseDetector.InitOpenPose();

	cout << "Opening file" << endl;
	auto outputFileName = "/home/mauricio/file.csv";
	std::ofstream outFile(outputFileName);

	cout << "Initializing processing" << endl;
	string textToWrite = "";
	for (uint index = 0; index < listVideos.size(); index++) {

		auto videoFile = listVideos.at(index);
		cout << "Opening video file" << videoFile << endl;
		auto listImages = ImageProcess::GetImagesFromVideo(videoFile);
		cout << "Total image length: " << listImages.size() << endl;

		for (uint i = 0; i < listImages.size(); i++) {
			if (i % 10 == 0) {
				cout << "Frame: "  << i << endl;
			}

			auto image = listImages.at(i);
			auto results = poseDetector.ExtractKeyPoints(image);

			cout << "Getting people amount " << results.GetPeopleAmount() << endl;

			for (uint j = 0; j < results.GetPeopleAmount(); j++) {
				string textLocal = "";
				if (i != 0 || j != 0 || index != 0) {
					textLocal += "\n";
				}

				auto partsNorm = results.GetPointsByPersonNorm(j);
				for (uint k = 0; k < partsNorm.size(); k++) {
					if (k != 0) {
						textLocal += ";";
					}

					textLocal += boost::str(boost::format("%.4f") % partsNorm.at(k).pos.x);
					textLocal += ";";
					textLocal += boost::str(boost::format("%.4f") % partsNorm.at(k).pos.y);
				}
				if (textLocal.find("inf") != string::npos) {
					cout << "Discarded by inf" << endl;
				} else {
					textToWrite += textLocal;
				}
			}
		}
	}


	cout << "CSV file: " << textToWrite << endl;
	cout << "Writing to file " << endl;

	outFile.write(textToWrite.c_str(), textToWrite.size());

	cout << "Routine executed" << endl;
}

void ClassMain::Clustering(int argc, char** argv) {
	cout << "Clustering" << endl;

	cout << "Initializing open pose" << endl;
	ClassOpenPose poseDetector;
	poseDetector.InitOpenPose();

	// Extract keypoints dummy image!
	string imagePath = defaultImage;
	cout << "ImagePath: " << imagePath << endl;
	Mat image1 = imread(imagePath);
	auto results = poseDetector.ExtractKeyPoints(image1);

	cout << "Loading file!" << endl;
	auto outputFileName = "/home/mauricio/file.csv";

	std::ifstream file(outputFileName);
	std::stringstream buffer;
	buffer << file.rdbuf();

	auto strFile = buffer.str();
	cout << "StrFile: " << strFile;

	cout << "Parsing File!" << endl;
	auto listElems = SplitStr(strFile, "\n");

	uint totalSamples = listElems.size();
	uint dim = 18 * 2; //2 dimensional points - 18 body parts
	uint newDim = 14 * 2; // 14 bodyParts of interest!

	// fill the data points
	cv::Mat points = cv::Mat::zeros(totalSamples, newDim, CV_32FC1);

	for (uint i = 0; i < listElems.size(); i++) {
		auto listLocal = SplitStr(listElems.at(i), ";");

		if (listLocal.size() != dim) {
			cerr << "Error split string " << listElems.at(i) << " size: " << listLocal.size() << endl;
			exit(1);
		}

		for(uint j = 0; j < newDim; j++) {
			points.at<float>(i, j) = stof(listLocal[j]);
		}
	}

	cout << "Training K-Means" << endl;

	cv::Mat labels; cv::Mat centers;
	uint clusters = 15;
    cv::kmeans(points, clusters, labels, cv::TermCriteria(CV_TERMCRIT_ITER | CV_TERMCRIT_EPS, 10000, 0.0001), 10, cv::KMEANS_PP_CENTERS, centers);

    for (int j = 0; j < centers.rows; ++j) {
    	// std::cout << centers.row(j) << std::endl;

    	vector<StructPoints> listPoints;
    	for (int k = 0; k < centers.cols; k += 2) {
    		// 14 * 2 = 28
    		StructPoints point;
    		point.person = j;
    		point.bodyPart = k / 2;
    		point.score = 1;
    		point.pos.x = centers.at<float>(j, k);
    		point.pos.y = centers.at<float>(j, k + 1);

    		listPoints.push_back(point);
    	}

    	for (int k = 14; k < 18; k++) {
    		StructPoints point;
    		point.bodyPart = k;
    		point.score = 0;
    		listPoints.push_back(point);
    	}


    	double factor = 40;
    	poseDetector.DrawPose(listPoints, true, factor);
    }



	cout << "Exit!" << endl;
}

vector<string> ClassMain::SplitStr(string str, string delimiter) {
	vector<string> list;

	auto s = str;
	size_t pos = 0;
	std::string token;
	while ((pos = s.find(delimiter)) != std::string::npos) {
	    token = s.substr(0, pos);
	    std::cout << token << std::endl;
	    list.push_back(token);
	    s.erase(0, pos + delimiter.length());
	}

	list.push_back(s);
	return list;
}

void ClassMain::TestDrawPose(int argc, char** argv) {
	cout << "Init Test Draw pose!" << endl;

	cout << "ShowKeyPoints" << endl;

	ClassOpenPose poseDetector;

	cout << "Initializing" << endl;
	poseDetector.InitOpenPose();

	string imagePath = defaultImage;

	if (argc > 2) {
		imagePath = string(argv[1]);
	}

	cout << "ImagePath: " << imagePath << endl;

	Mat image1 = imread(imagePath);

	cout << "Extracting data" << endl;
	auto results = poseDetector.ExtractKeyPoints(image1);
	auto listPoints = results.GetPointsByPerson(0); // First person assuming

	cout << "Showing points!" << endl;
	poseDetector.DrawPose(listPoints);

	listPoints = results.GetPointsByPersonNorm(0);
	auto factor = results.factor;

	cout << "Showing points norm!" << endl;
	poseDetector.DrawPose(listPoints, true, factor);

	cout << "End!" << endl;
}

void ClassMain::TestVideoCapInfo(int argc, char** argv) {
	cout << "Testing video cap info" << endl;
	cout << "Opening file" << endl;

	string fileName = "/home/mauricio/Videos/Datasets/Weizzman/jump/daria_jump.avi";
	auto listFrames = ImageProcess::GetImagesFromVideo(fileName); // Just for testing
	cout << "List frames count: " << listFrames.size() << endl;

	VideoCapInfo info(fileName);
	if (info.IsOpened() == false) {
		cout << "Error loading file" << endl;
	} else {
		cout << "Loading frames" << endl;
		int count = 0;
		while(true) {
			FrameInfo frameInfo = info.GetNextImage();
			if (frameInfo.isEmpty == true) {
				break;
			}

			count++;
			cout << "Counting frame " << count << endl;
			cout << "Len: "  << frameInfo.len << endl;
		}
	}

	cout << "Finished!" << endl;
}

void ClassMain::TestVideoWrapper(int argc, char** argv) {
	cout << "Testing video cap info" << endl;
	cout << "Opening file" << endl;

	string fileName = "/home/mauricio/Videos/Datasets/Weizzman/jump/daria_jump.avi";
	auto listFrames = ImageProcess::GetImagesFromVideo(fileName); // Just for testing
	cout << "List frames count: " << listFrames.size() << endl;



	auto guidStr = ClassWrapper_LoadVideo(fileName);

	if (guidStr.compare("") == 0) {
		cout << "Can't open file" << endl;
	} else {
		cout << "Loading frames" << endl;
		int count = 0;
		while(true) {
			FrameInfo frameInfo = ClassWrapper_GetNextImage("hola");
			if (frameInfo.isEmpty == true) {
				break;
			}

			count++;
			cout << "Counting frame " << count << endl;
			cout << "Len: "  << frameInfo.len << endl;
		}
	}

	cout << "Finished!" << endl;
}

void ClassMain::TestConvertVideoMJPEG(int argc, char** argv) {
	cout << "Testing convert video MJPEG" << endl;

	string fileName = "/home/mauricio/Videos/mjpeg/video2.mjpeg";

	cout << "Extract frames" << endl;
	auto list = ClassMJPEGReader::ProcessVideo(fileName);

	cout << "Total videos in list: " << list.size() << endl;

	// Trying to iterate in element
	for (int i = 0; i < 5; i++) {
		cout << "Counting elements" << endl;
		Mat image = ImageProcess::GetFromCharBuffer(list.at(0).image, list.at(0).len);
		ImageProcess::ShowAndWait(image);
	}


	cout << "Done!" << endl;

}
