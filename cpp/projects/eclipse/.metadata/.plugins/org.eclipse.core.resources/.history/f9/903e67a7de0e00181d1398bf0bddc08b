#include "ImageProcess.h"

using namespace std;

// Variable redefinition
const int ImageProcess::EROSION_SIZE = 1;
const int ImageProcess::DILATION_SIZE = 1;

ImageProcess::ImageProcess()  {
	// Empty constructor
}

cv::Mat ImageProcess::Erode(cv::Mat image, int shape) {
    cv::Mat erosion_dst;
    cv::Mat element = cv::getStructuringElement(shape, cv::Size(2*EROSION_SIZE + 1, 2*EROSION_SIZE+1),
			cv::Point(EROSION_SIZE, EROSION_SIZE));
    erode(image, erosion_dst, element );
    return erosion_dst;
}

cv::Mat ImageProcess::Dilate(cv::Mat image, int shape) {
	cv::Mat dilate_dst;
    cout << "Applying dilating operation" << endl;
    cv::Mat element = cv::getStructuringElement(shape, cv::Size(2*DILATION_SIZE + 1, 2*DILATION_SIZE+1),
    		cv::Point(DILATION_SIZE, DILATION_SIZE));
    cv::dilate(image, dilate_dst, element);
    return dilate_dst;
}

cv::Mat ImageProcess::Threshold(cv::Mat image, double threshValue, int type) {
	cv::Mat result;
	cv::threshold(image, result, threshValue, 255, type);
    return result;
}

cv::Mat ImageProcess::Grayscale(cv::Mat image) {
	cv::Mat result;
	cv::cvtColor(image, result, CV_BGR2GRAY);
    return result;
}


cv::Mat ImageProcess::Blur(cv::Mat image) {
	cv::Mat result;
	cv::blur(image, result, cv::Size(3, 3));
    return result;
}

void ImageProcess::ShowAndWait(cv::Mat image) {
	cv::namedWindow("ImageShow", CV_WINDOW_AUTOSIZE);
	cv::imshow("ImageShow", image);
	cv::waitKey(0);
	cv::destroyWindow("ImageShow");
}

cv::Mat ImageProcess::HistEqualization(cv::Mat image) {
	cv::Mat result;
	cv::equalizeHist(image, result);
    return result;
}

cv::Mat ImageProcess::BlurGaussian(cv::Mat image) {
	cv::Mat result;
	cv::GaussianBlur(image, result, cv::Size(3, 3), 0, 0);
    return result;
}


void ImageProcess::ShowSingleImage(cv::Mat image) {
    cvNamedWindow("image", CV_WINDOW_AUTOSIZE);
    imshow("image", image);
    cv::waitKey(0);
    cv::destroyWindow("image");
}

double ImageProcess::GetMean(cv::Mat image) {
    double result;

    if (image.type() != CV_8UC1) {
        cout << "Image is not grayscale" << endl;
        result = -1;
    } else {
        double mean = 0;
        int counter = 0;

        for (int x = 0; x < image.cols; x++) {
            for (int y = 0; y < image.rows; y++) {
            	cv::Scalar intensity = image.at<uchar>(y, x);
                auto value = intensity.val[0];

                mean += value;
                counter++;
            }
        }

        mean = mean / counter;
        result = mean;
    }

    return result;
}

double ImageProcess::GetAverageColor(cv::Mat mat, cv::Rect region) {
	auto imageCrop = mat(region);

	cv::Mat imageHSV;

	cv::cvtColor(imageCrop, imageHSV, CV_BGR2HSV);

	// Hue range: [0, 179]
	double hueCount = 0;
	int pixelCount = 0;
	for (int i = 0; i < imageHSV.rows; i++) {
		for (int j = 0; j < imageHSV.cols; j++) {
			cv::Vec3b pixel = imageHSV.at<cv::Vec3b>(i, j);

			auto hue = pixel.val[0];

			hueCount += (double)hue;
			pixelCount++;
		}
	}

	return hueCount / pixelCount;
}

std::vector<cv::Mat> ImageProcess::GetImagesFromVideo(std::string videoPath) {
	std::vector<cv::Mat> listImages;

	cv::VideoCapture cap(videoPath);
	if (cap.isOpened() == false) {
		std::cerr << "Error opening path " << videoPath;
		exit(1);
	} else {
		for (;;) {
			cv::Mat frame;
			cap >> frame;

			if (frame.empty()) {
				break;
			} else {
				listImages.push_back(frame);
			}
		}
	}

	return listImages;

}



